classdef LinearizedBicycleModel < MotionModel
    properties
        Ts
        states
        propagated_states
        % A matrix in case of linear systems, jacobian matrix F in case of
        % non linear
        F_matrix
        %discretized F matrix (A) matrix
        Fd_matrix
        Bd_matrix
        vehicleParameters
        a22_c
        a24_c
        a42_c
        a44_c
        bb_2
        bb_4
        V
    end
    
    methods
        function obj = LinearizedBicycleModel(V, Ts, vp)
            if nargin == 0
                % Init to a default vehicle
                V = 0;
                vp = SedanBicycleModelParameters();
                Ts = 0.1;
            elseif nargin == 1
                vp = SedanBicycleModelParameters();
                Ts = 0.1;
            elseif nargin == 2
                vp = SedanBicycleModelParameters();
            end
            
            obj.V = V;
            obj.Ts = Ts;
            
            % use the model from rajamani, with lateral velocity and yaw
            % rate as states - [y vy psi psi_dot]
            
            obj.a22_c = -(vp.C_f + vp.C_r)/vp.m;
            obj.a24_c = (vp.C_f*vp.l_f - vp.C_r*vp.l_r)/vp.m;  
            obj.a42_c = - (vp.C_f*vp.l_f - vp.C_r * vp.l_r)/vp.Jz;
            obj.a44_c = - (vp.l_f^2 * vp.C_f + vp.l_r^2 * vp.C_r)/vp.Jz;
            obj.vehicleParameters = vp;
            obj.bb_2 = vp.C_f/vp.m;
            obj.bb_4 = vp.C_f*vp.l_f/vp.Jz;
                        
        end
        
        function calculateDiscretizedMatrices(obj, V)
            obj.F_matrix = obj.calculateContinuousStateTransitionMatrix(V);
            
            % disretize using Euler forward
            obj.Fd_matrix = expm(obj.F_matrix * obj.Ts);
            
            
        end
        
        function  x_apriori = propagate(obj, x, u)
        end
        
        function F = calculateContinuousStateTransitionMatrix(obj, Vx)
            
            % v_dot = -(c1+c2)/(mV^2)v-1/mV(mV+(ac1-bc2)/V)r + c1/(mV) delta
            % r_dot = (-ac1+bc2)/(JzV)v-(a^2C1+b^2C2)/(JzV)r + (ac1/Jz)delta
            % Its important to leave only in terms of V as a variable.
            % i.e., calculate all the other coefficients axx_c beforehand,
            % and then substitute V at runtime.
            a22 = obj.a22_c/Vx;
            a24 = -Vx - obj.a24_c/Vx;
            a42 = obj.a42_c/Vx;
            a44 = obj.a44_c/Vx;
            F = [0 1 0 0; ...
                0 a22 0 a24; ...
                0 0 0 1; ...
                0 a42 0 a44];
        end
        
        function B = getInputMatrix(obj)
            B = [0; obj.bb_2; 0; obj.bb_4];
        end
        
        function Fd = linearizedDiscreteStateTransitionMatrix(obj, x, u)
            % x not used since the system is linear
            Fd = obj.Fd_matrix;
        end
        
    end
end